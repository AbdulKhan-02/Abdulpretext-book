import util from "util";
import { toXml } from "xast-util-to-xml";
import { fromXml } from "xast-util-from-xml";
import { XastRoot } from "../src/utils/xast/types";
import { Plugin, unified } from "unified";
import { stripCommentsAndFriendsPlugin } from "../src/stages/0-normalize/plugin-strip-comments";
import { expandCdataPlugin } from "../src/stages/0-normalize/plugin-expand-cdata";
import { mergeAdjacentTextPlugin } from "../src/stages/0-normalize/plugin-merge-adjacent-text";
import { removeUnneededTextPlugin } from "../src/stages/0-normalize/plugin-remove-unneeded-text";
import { createNodeToSchemaMapPlugin } from "../src/stages/helpers/plugin-create-node-to-schema-map";
import { JsonGrammar } from "../src/utils/relax-ng/types";
import { normalizePretextPlugin } from "../src/stages/0-normalize/plugin-normalize-pretext";
import { findRootElementPlugin } from "../src/stages/0-normalize/plugin-find-root-element";
/* eslint-env jest */

// Make console.log pretty-print by default
const origLog = console.log;
console.log = (...args) => {
    origLog(...args.map((x) => util.inspect(x, false, 10, true)));
};

const toXmlPlugin = function () {
    Object.assign(this, { Compiler: toXml });
} as Plugin<never[], XastRoot, string>;

describe("Stage 0 tests", () => {
    /* JsonGrammar generated by the following rnc grammar.
grammar {
	start = Start


	Start = element root {
		(A | B)*
	}
	A = element a { 
		C1* 
	}
	B = element b { C2 }
	C1 = element c { text }
	C2 = element c { D }
	D = element d { text }
}
    */
    const jsonGrammar: JsonGrammar = {
        startType: "ElementStart",
        refs: {
            XMLText: {
                type: "text",
            },
            ElementStart: {
                type: "element",
                name: "root",
                attributes: {},
                children: [
                    {
                        ref: "ElementA",
                    },
                    {
                        ref: "ElementB",
                    },
                ],
                textChildrenAllowed: false,
            },
            ElementB: {
                type: "element",
                name: "b",
                attributes: {},
                children: [
                    {
                        ref: "ElementC2",
                    },
                ],
                textChildrenAllowed: false,
            },
            ElementC2: {
                type: "element",
                name: "c",
                attributes: {},
                children: [
                    {
                        ref: "ElementD",
                    },
                ],
                textChildrenAllowed: false,
            },
            ElementD: {
                type: "element",
                name: "d",
                attributes: {},
                children: [],
                textChildrenAllowed: true,
            },
            ElementA: {
                type: "element",
                name: "a",
                attributes: {},
                children: [
                    {
                        ref: "ElementC1",
                    },
                ],
                textChildrenAllowed: false,
            },
            ElementC1: {
                type: "element",
                name: "c",
                attributes: {},
                children: [],
                textChildrenAllowed: true,
            },
        },
    };
    it("Can remove XML comments", async () => {
        let source: string;
        source = `<pretext><!--foo--><article xml:id="hello-world"><p>Hello, World!</p><b>foo</b></article><baz /></pretext>`;
        const ast = fromXml(source) as XastRoot;

        const processor = unified().use(stripCommentsAndFriendsPlugin);
        const processed = processor.runSync(ast);
        expect(toXml(processed)).toEqual(
            '<pretext><article xml:id="hello-world"><p>Hello, World!</p><b>foo</b></article><baz></baz></pretext>'
        );
    });
    it("Can convert cdata to text", () => {
        let source: string;
        source = `<pretext><!--foo--><article xml:id="hello-world"><![CDATA[Some text & invalid chars! <foo/>]]></article></pretext>`;
        let ast: XastRoot = { type: "root", children: [] };
        ast = fromXml(source) as XastRoot;

        const processor = unified().use(expandCdataPlugin);
        const processed = processor.runSync(ast);
        expect(toXml(processed)).toEqual(
            '<pretext><!--foo--><article xml:id="hello-world">Some text &#x26; invalid chars! &#x3C;foo/></article></pretext>'
        );
    });
    it("Can merge adjacent text nodes", () => {
        let ast: XastRoot = {
            type: "root",
            children: [
                {
                    type: "element",
                    name: "foo",
                    children: [
                        { type: "text", value: "text1" },
                        { type: "text", value: "text2" },
                    ],
                },
            ],
        };

        const processor = unified().use(mergeAdjacentTextPlugin);
        const processed = processor.runSync(ast);
        expect(processed).toEqual({
            type: "root",
            children: [
                {
                    type: "element",
                    name: "foo",
                    children: [{ type: "text", value: "text1text2" }],
                },
            ],
        });
    });
    it("Can remove unneeded whitespace based on schema data", () => {
        // No whitespace: shouldn't change
        {
            const source = `<root><a><c>hi</c></a><b><c><d>there</d></c></b></root>`;
            const ast = fromXml(source) as XastRoot;
            const nodeToSchemaMap = new Map();
            // Set up the processor
            const processor = unified()
                .use(createNodeToSchemaMapPlugin, {
                    schema: jsonGrammar,
                    nodeToSchemaMap,
                })
                .use(removeUnneededTextPlugin, {
                    schema: jsonGrammar,
                    nodeToSchemaMap,
                });
            const processed = processor.runSync(ast);
            expect(toXml(processed)).toEqual(
                "<root><a><c>hi</c></a><b><c><d>there</d></c></b></root>"
            );
        }

        // Lots of whitespace: it should all be trimmed
        {
            const source = `<root>
                                <a>
                                    <c>hi</c>
                                </a>
                                <b>
                                    <c>
                                        <d>there</d>
                                    </c>
                                </b>
                            </root>`;
            const ast = fromXml(source) as XastRoot;
            const nodeToSchemaMap = new Map();
            // Set up the processor
            const processor = unified()
                .use(createNodeToSchemaMapPlugin, {
                    schema: jsonGrammar,
                    nodeToSchemaMap,
                })
                .use(removeUnneededTextPlugin, {
                    schema: jsonGrammar,
                    nodeToSchemaMap,
                });
            const processed = processor.runSync(ast);
            expect(toXml(processed)).toEqual(
                "<root><a><c>hi</c></a><b><c><d>there</d></c></b></root>"
            );
        }

        // Some whitespace that gets trimmed, but the whitespace inside of `<d>...</d>` should not be trimmed.
        {
            const source = `<root>
                                <a>
                                    <c>hi</c>
                                </a>
                                <b>
                                    <c>
                                        <d>
                                        </d>
                                    </c>
                                </b>
                            </root>`;
            const ast = fromXml(source) as XastRoot;
            const nodeToSchemaMap = new Map();
            // Set up the processor
            const processor = unified()
                .use(createNodeToSchemaMapPlugin, {
                    schema: jsonGrammar,
                    nodeToSchemaMap,
                })
                .use(removeUnneededTextPlugin, {
                    schema: jsonGrammar,
                    nodeToSchemaMap,
                });
            const processed = processor.runSync(ast);
            expect(toXml(processed)).toEqual(
                "<root><a><c>hi</c></a><b><c><d>\n                                        </d></c></b></root>"
            );
        }
    });
    it("Can extract pretext element", () => {
        const source = `<?xml version="1.0" encoding="UTF-8" ?>

        <!-- comment -->
        
        <pretext><p>Hello, World!</p></pretext>`;
        const ast = fromXml(source) as XastRoot;
        // Set up the processor
        const processor = unified().use(findRootElementPlugin);
        const processed = processor.runSync(ast);
        expect(toXml(processed)).toEqual(
            "<pretext><p>Hello, World!</p></pretext>"
        );
    });
    it("Can normalize pretext document", () => {
        const source = `<pretext>
        <!-- a comment -->
                    <article xml:id="hello-world">
                       <p>Hello, World!</p>
                       <p><![CDATA[other <stuff>]]></p>
                    </article>
                </pretext>`;
        const ast = fromXml(source) as XastRoot;
        // Set up the processor
        const processor = unified().use(normalizePretextPlugin);
        const processed = processor.runSync(ast);
        expect(toXml(processed)).toEqual(
            '<pretext><article xml:id="hello-world"><p>Hello, World!</p><p>other &#x3C;stuff></p></article></pretext>'
        );
    });
});
